#Code to accompany the paper
#"The Behavior of a Three-Term Hofstadter-Like Recurrence
#with Linear Initial Conditions

#All sequences in this module are generated by the recurrence relation
#B(n) = B(n - B(n - 1)) + B(n - B(n - 2)) + B(n - B(n - 3))

#Throughout this code, the term "nonstandard integer" appears.
#A nonstandard integer, in this context, is a linear combination of
#1 and N, where N is an integer that's greater than all positive integers.
#Data structure-wise, we represent the nonstandard integer a*N+b by the
#tuple (a, b).
#
#We think of N in this way but also as a symbol representing a large positive
#integer. With the latter setting in mind, we track lower bounds on N
#that guarantee that all our computations are valid.

##Some global lookup tables and logs
#All terms computed so far
lookup = dict()
#The most recently computed bound on N, obtained the last
#time that lkp was called.
Nlog = None
#All lower bounds on N computed so far
Nlogs = dict()

#Reset the environment
def reset():
    global lookup, Nlogs
    lookup = dict()
    Nlogs = dict()

#If do_anything is true, replace the (presumably) int n
#with the nonstandard integer 0*N+n, represented as (0, n).
#If do_anything is false, return n unchanged.
def nonstdize(n, do_anything):
    if do_anything:
        return (0, n)
    else:
        return n

#Look up a previously computed sequence term or a term
#defined by an initial condition.
#
#Inputs:
#n: The index of the term to look up, an integer or a nonstandard integer
#ic: The initial conditions of the sequence being looked up, starting from
#    index 1. All terms must be integers. If ic is None, the nonstandard
#    initial conditions 1, 2, 3, ..., N are used.
#zeros: True if all terms at nonpositive indices are taken to be 0; False if
#       they are taken to be undefined.
#mod7: The congruence class of N mod 7, passed only if we are in the process
#      of computing terms with indices greater than 2*N.
#
#Output: The value of the looked-up term
#        Also, the value of Nlog becomes whatever lower bound on N was required
#        for the computation to be valid (or None if no such assumption was needed)
#        In the output, False means "not found," and None means "undefined."
def lkp(n, ic, zeros = False, mod7 = -1):
    global Nlog
    #Reset Nlog
    Nlog = None
    #Determine if we're working with nonstandard integers
    nonstd = (ic is None)
    #Is n itself represented as a nonstandard integer?
    if isinstance(n, tuple):
        #Fail for a nonstandard input for a standard sequence
        if ic is not None:
            return None
        #Input is actually a positive integer
        elif n[0] == 0 and n[1] > 0:
            #N must be at least as large as that integer
            Nlog = n[1]
            return n
        #Input has a negative coefficient on N
        elif n[0] <= 0:
            if n[1] > 0:
                #The input must be negative
                Nlog = -n[1] / n[0]
            #Set n to -1 and fall through to the standard case
            n = -1
        #Input has a coefficient of 1 on N
        elif n[0] == 1:
            #It's N minus something (or it's just N)
            #That should land in the initial condition
            if n[1] <= 0:
                #Force it to land in the initial condition
                Nlog = 1 - n[1]
                return n
            #It's a term we've previously computed
            elif n[1] <= len(lookup[(None, zeros)]):
                return lookup[(None, zeros)][n[1] - 1]
            #It's a term described by Theorem 2 in the paper, and
            #we're trying to compute terms after Theorem 2 has stopped applying
            elif mod7 >= 0 and n[1] >= 67:
                nu_val = nu(mod7)
                #Force the index to exceed the range for which Theorem 2 applies
                Nlog = n[1] - nu_val
                return BNpattern(n, mod7)
            #Fail case
            else:
                return False
        #The coefficient on N is 2
        elif n[0] == 2:
            nu_val = nu(mod7)
            #Theorem 2 applies
            if n[1] <= nu_val:
                #Force Theorem 2 to apply
                Nlog = 67 - n[1]
                return BNpattern(n, mod7)
            #Theorem 2 does not apply, but we've already computed this term
            elif n[1] - nu_val <= len(lookup[(None, zeros, mod7)]):
                return lookup[(None, zeros, mod7)][n[1] - nu_val - 1]
            else:
                return False
        #The coefficient on N is none of the above
        #Fail for all of those
        else:
            return False
    #Default 0 from the initial condition
    if n <= 0 and zeros:
        #Output in the proper form
        return nonstdize(0, nonstd)
    #Index is nonpositive and there's no default 0
    elif n <= 0:
        return None
    #Term is in the initial condition, or we've already computed it
    elif n <= len(lookup[(ic, zeros)]):
        #Output in the proper form
        return nonstdize(lookup[(ic, zeros)][n - 1], nonstd)
    #Fail case
    else:
        return False

#Compute terms of sequences with (standard) integer initial conditions
#
#Inputs:
#n: Integer index
#ic: Initial values, starting from index 1
#zeros: True if all terms at nonpositive indices are taken to be 0; False if
#       they are taken to be undefined.
#
#Output: The value of the nth term
def B(n, ic, zeros = False):
    if not isinstance(ic, tuple):
        ic = tuple(ic)
    #Make sure this sequence has an entry in the lookup table
    if (ic, zeros) not in lookup:
        lookup[(ic, zeros)] = list(ic)
    #Look up this term
    ret = lkp(n, ic, zeros)
    #If it was found, return it
    if ret is not False:
        return ret
    else:
        #Evaluate the recurrence to compute the needed term
        call1 = B(n - 1, ic, zeros)
        call2 = B(n - 2, ic, zeros)
        call3 = B(n - 3, ic, zeros)
        #Check for death
        if call1 is None or call2 is None or call3 is None or call1 == 0 or call2 == 0 or call3 == 0:
            term = None
        else:
            #Do the outer evaluations
            idx1 = n - call1
            idx2 = n - call2
            idx3 = n - call3
            term1 = B(idx1, ic, zeros)
            term2 = B(idx2, ic, zeros)
            term3 = B(idx3, ic, zeros)
            #Check for death again
            if term1 is None or term2 is None or term3 is None or\
                    term1 is False or term2 is False or term3 is False:
                term = None
            else:
                #Term is defined
                term = term1 + term2 + term3
        #Add the term to the lookup table
        lookup[(ic, zeros)].append(term)
        return term

#Compute the first n terms of the sequence with given initial conditions
def Bseq(n, ic, zeros = False):
    ic = tuple(ic)
    return [B(k, ic, zeros) for k in range(1, n + 1)]

#Find the last defined term of a sequence.
#Output the pair (index, value) corresponding to it.
def lastTerm(seq):
    idx = seq.index(None)
    return (idx, seq[idx - 1])

### ARITHMETIC ON NONSTANDARD INTEGERS ###

#Subtraction
def nonstdminus(n1, n2):
    if isinstance(n2, int):
        n2 = (0, n2)
    return (n1[0] - n2[0], n1[1] - n2[1])

#Addition
def nonstdplus(*nvals):
    return (sum([nvals[i][0] for i in range(len(nvals))]),\
            sum([nvals[i][1] for i in range(len(nvals))]))

#Scalar multiplication (i.e. multiplication by a standard integer)
def nonstdscale(n, c):
    return (n[0] * c, n[1] * c)

#Modulus
#Computes n mod m, where N is congruent to mod mod m
def nonstdmod(n, m, mod):
    return (n[0] * mod + n[1]) % m

#Compute terms of the sequence with initial conditions 1, 2, 3, ..., N
#
#Inputs:
#n: Nonstandard integer index
#zeros: True if all terms at nonpositive indices are taken to be 0; False if
#       they are taken to be undefined.
#mod7: If 0 through 6, the value of N mod 7. (Default is -1, meaning we don't know.)
#
#Output: The value of the nth term
def BN(n, zeros = False, mod7 = -1):
    global Nlog, Nlogs
    #Make sure this sequence has an entry in the lookup table
    if (None, zeros) not in lookup:
        lookup[(None, zeros)] = []
    #If mod7 is relevant, make sure this sequence has an entry in the lookup table
    if isinstance(n, tuple) and n[0] == 2 and\
            (None, zeros, mod7) not in lookup:
        lookup[(None, zeros, mod7)] = []
    if isinstance(n, int):
        n = (1, n)
    #Make sure this value of n can come with bounds on N
    if n not in Nlogs:
        Nlogs[n] = set()
    #Look up this term
    ret = lkp(n, None, zeros, mod7)
    #If it was found, return it
    if ret is not False:
        return ret
    else:
        #Evaluate the recurrence to compute the needed term
        #Along the way, track the N bounds
        call1 = BN(nonstdminus(n, 1), zeros, mod7)
        if Nlog is not None:
            Nlogs[n].add(Nlog)
        call2 = BN(nonstdminus(n, 2), zeros, mod7)
        if Nlog is not None:
            Nlogs[n].add(Nlog)
        call3 = BN(nonstdminus(n, 3), zeros, mod7)
        if Nlog is not None:
            Nlogs[n].add(Nlog)
        #Check for death
        if call1 is None or call2 is None or call3 is None or call1 == (0, 0) or call2 == (0, 0) or call3 == (0, 0):
            term = None
        else:
            #Do the outer evaluations
            idx1 = nonstdminus(n, call1)
            idx2 = nonstdminus(n, call2)
            idx3 = nonstdminus(n, call3)
            term1 = BN(idx1, zeros, mod7)
            if Nlog is not None:
                Nlogs[n].add(Nlog)
            term2 = BN(idx2, zeros, mod7)
            if Nlog is not None:
                Nlogs[n].add(Nlog)
            term3 = BN(idx3, zeros, mod7)
            if Nlog is not None:
                Nlogs[n].add(Nlog)
            #Check for death again
            if term1 is None or term2 is None or term3 is None or\
                    term1 is False or term2 is False or term3 is False:
                term = None
            else:
                #Term is defined
                term = nonstdplus(term1, term2, term3)
        #Add the term to the lookup table
        if n[0] == 2:
            lookup[(None, zeros, mod7)].append(term)
        else:
            lookup[(None, zeros)].append(term)
        return term

#Compute terms N + 1 through N + n of the sequence with initial conditions 1, 2, ..., N
def BNseq(n, zeros = False):
    return [BN(k, zeros) for k in range(1, n + 1)]

#Compute all terms of the sequence with initial conditions 1, 2, ..., N after Theorem 2 stops applying
def B2Nseq(n, mod7):
    nu_val = nu(mod7)
    return [BN((2, k), True, mod7) for k in range(nu_val + 1, n + 1)]

#Implementation of the pattern described in Theorem 2
def BNpattern(n, mod7 = 0, N = None):
    if isinstance(n, int):
        r = (n - N) % 7
        k = (n - N) // 7
        isint = True
    else:
        nn = nonstdminus(n, (1, 0))
        r = nonstdmod(nn, 7, mod7)
        k7 = nonstdminus(nn, r)
        k = nonstdscale(k7, 1 / 7)
        isint = False
    if r == 0:
        if isint:
            return (0, 7*k + 2)
        else:
            return nonstdminus(k7, -2)
    elif r == 1:
        if isint:
            return (1, 7*k + 2)
        else:
            return nonstdplus(k7, (1, 2))
    elif r == 2:
        if isint:
            return (1, 7*k + 4)
        else:
            return nonstdplus(k7, (1, 4))
    elif r == 3:
        return (0, 7)
    elif r == 4:
        if isint:
            return (2, 2*k + 45)
        else:
            ret = nonstdplus(nonstdscale(k, 2), (2, 45))
            if abs(ret[0] - round(ret[0])) < 1e-5:
                ret = (round(ret[0]), ret[1])
            if abs(ret[1] - round(ret[1])) < 1e-5:
                ret = (ret[0], round(ret[1]))
            return ret
    elif r == 5:
        if isint:
            return (2, k - 7)
        else:
            ret = nonstdplus(k, (2, -7))
            if abs(ret[0] - round(ret[0])) < 1e-5:
                ret = (round(ret[0]), ret[1])
            if abs(ret[1] - round(ret[1])) < 1e-5:
                ret = (ret[0], round(ret[1]))
            return ret
    elif r == 6:
        return (1, -2)

#nu value from Theorem 2 in the paper
def nu(N):
    return max(-2, -4 + ((3 - N) % 7))

#Convert nonstandard integers to strings
#If inline is False, the strings are LaTeX code
def strgize(ntuple, inline = True):
    if ntuple is None:
        return "Undefined"
    elif ntuple[0] == 0:
        return str(ntuple[1])
    elif ntuple[0] == 1 and ntuple[1] > 0:
        return "N + %d" % ntuple[1]
    elif ntuple[0] == 1 and ntuple[1] == 0:
        return "N"
    elif ntuple[0] == 1:
        return "N - %d" % (-ntuple[1])
    elif ntuple[0] == -1 and ntuple[1] > 0:
        return "-N + %d" % ntuple[1]
    elif ntuple[0] == -1 and ntuple[1] == 0:
        return "-N"
    elif ntuple[0] == -1:
        return "-N - %d" % (-ntuple[1])
    elif not isinstance(ntuple[0], int):
        num = round(ntuple[0]*7)
        if num == 1:
            if inline:
                piece1 = "N/7"
            else:
                piece1 = "\\frac{N}{7}"
        elif num == -1:
            if inline:
                piece1 = "-N/7"
            else:
                piece1 = "-\\frac{N}{7}"
        else:
            if inline:
                piece1 = "%dN/7" % num
            elif num > 0:
                piece1 = "\\frac{%dN}{7}" % num
            else:
                piece1 = "-\\frac{%dN}{7}" % (-num)
        if abs(round(ntuple[1]) - ntuple[1]) < 1e-5:
            n1 = round(ntuple[1])
            if n1 == 0:
                return piece1
            elif n1 > 0:
                return "%s + %d" % (piece1, n1)
            elif n1 < 0:
                return "%s - %d" % (piece1, -n1)
        else:
            num2 = round(ntuple[1]*7)
            if num2 > 0:
                if inline:
                    return "%s + %d/7" % (piece1, num2)
                else:
                    return "%s + \\frac{%d}{7}" % (piece1, num2)
            else:
                if inline:
                    return "%s - %d/7" % (piece1, -num2)
                else:
                    return "%s - \\frac{%d}{7}" % (piece1, -num2)
    elif ntuple[1] > 0:
        return "%dN + %d" % ntuple
    elif ntuple[1] == 0:
        return "%dN" % ntuple[0]
    else:
        return "%dN - %d" % (ntuple[0], -ntuple[1])